# -*- coding: utf-8 -*-
"""Evasao_de_clientes.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/192SZjOZJ6EAUZqbMNwFX9inaeOg7tyF8
"""

import pandas as pd

"""# Extração de dados"""

url = 'https://raw.githubusercontent.com/alura-cursos/challenge2-data-science/refs/heads/main/TelecomX_Data.json'
dados_brutos = pd.read_json(url)
dados_brutos.head(5)

"""normalizar json"""

customer_data = pd.json_normalize(dados_brutos['customer'])
phone_data = pd.json_normalize(dados_brutos['phone'])
internet_data = pd.json_normalize(dados_brutos['internet'])
account_data = pd.json_normalize(dados_brutos['account'])

dados_normalizados = pd.concat([dados_brutos.drop(columns=['customer', 'phone', 'internet', 'account']), customer_data, phone_data, internet_data, account_data], axis=1)
dados_normalizados.head(5)

"""# Transformação

tipos de dados de cada coluna
"""

dados_normalizados.info()

"""Dicionário de dados

customerID: número de identificação único de cada cliente

Churn: se o cliente deixou ou não a empresa

gender: gênero (masculino e feminino)

SeniorCitizen: informação sobre um cliente ter ou não idade igual ou maior que 65 anos

Partner: se o cliente possui ou não um parceiro ou parceira

Dependents: se o cliente possui ou não dependentes

tenure: meses de contrato do cliente

PhoneService: assinatura de serviço telefônico

MultipleLines: assisnatura de mais de uma linha de telefone

InternetService: assinatura de um provedor internet

OnlineSecurity: assinatura adicional de segurança online

OnlineBackup: assinatura adicional de backup online

DeviceProtection: assinatura adicional de proteção no dispositivo

TechSupport: assinatura adicional de suporte técnico, menos tempo de espera

StreamingTV: assinatura de TV a cabo

StreamingMovies: assinatura de streaming de filmes

Contract: tipo de contrato

PaperlessBilling: se o cliente prefere receber online a fatura

Charges.Monthly: total de todos os serviços do cliente por mês

PaymentMethod: forma de pagamento

Charges.Total: total gasto pelo cliente

ausencia de valores
"""

dados_normalizados.isnull().sum()

"""dados duplicados"""

dados_normalizados.duplicated().sum()

"""mudar a coluna Charges.Total	para se tornar uma coluna númerica"""

import numpy as np

dados_normalizados['Charges.Total'] = dados_normalizados['Charges.Total'].apply(lambda x: x.replace('.', '').strip())

dados_normalizados['Charges.Total'] = dados_normalizados['Charges.Total'].replace('', np.nan)

dados_normalizados['Charges.Total'] = dados_normalizados['Charges.Total'].astype(np.float64)

dados_normalizados.info()

"""

verificar valores com nan
"""

dados_normalizados['Charges.Total'].isna().sum()

#colocando mediana em valores com Nan
dados_normalizados['Charges.Total']=dados_normalizados['Charges.Total'].fillna(0)

# criar a coluna "Contas_Diarias"
dados_normalizados['Contas_Diarias']=dados_normalizados['Charges.Monthly']/30
dados_normalizados.head(5)

"""Tradução de colunas"""

dados_normalizados = dados_normalizados.rename(columns={
    'customerID': 'id_cliente',
    'Churn': 'desistência',
    'gender': 'genero',
    'SeniorCitizen': 'idoso',
    'Partner': 'tem_parceiro',
    'Dependents': 'tem_dependentes',
    'Tenure': 'meses_contrato',
    'PhoneService': 'telefone',
    'MultipleLines': 'multiplas_linhas',
    'InternetService': 'tipo_internet',
    'OnlineSecurity': 'seguranca_online',
    'OnlineBackup': 'backup_online',
    'DeviceProtection': 'protecao_dispositivo',
    'TechSupport': 'suporte_tecnico',
    'StreamingTV': 'tv_streaming',
    'StreamingMovies': 'filmes_streaming',
    'Contract': 'tipo_contrato',
    'PaperlessBilling': 'fatura_online',
    'PaymentMethod': 'forma_pagamento',
    'Charges.Monthly': 'faturamento_mensal',
    'Charges.Total': 'faturamento_total'
})

dados_normalizados.head(1)

"""Conversão de algumas colunas para se tornarem valores binários



"""

# Lista das colunas a transformar
colunas_binarias = [
    'desistência', 'tem_parceiro', 'tem_dependentes', 'multiplas_linhas',
    'seguranca_online', 'backup_online', 'protecao_dispositivo', 'suporte_tecnico',
    'tv_streaming', 'filmes_streaming', 'fatura_online', 'telefone'
]

# Aplicar transformação: 'yes' → 1, tudo o resto → 0
for col in colunas_binarias:
    dados_normalizados[col] = dados_normalizados[col].apply(
        lambda x: 1 if str(x).strip().lower() == 'yes' else 0
    ).astype('int64')

# Exibir o resultado
dados_normalizados.head()

"""# Carga e Análise (L - Load & Analysis)

Métricas como média, mediana, desvio padrão
"""

dados_normalizados.describe()

"""criação de gráfico de evasão"""

import matplotlib.pyplot as plt

contagem_churn = dados_normalizados['desistência'].value_counts()
labels = ['Permaneceram', 'Saíram']
cores = ['#4CAF50', '#E74C3C']

fig, ax = plt.subplots(figsize=(6, 6))

wedges, texts, autotexts = ax.pie(
    contagem_churn,
    labels=labels,
    colors=cores,
    startangle=90,
    autopct='%1.1f%%',
    textprops={'fontsize': 12, 'color': 'black'},
    wedgeprops={'edgecolor': 'white', 'linewidth': 1.5}
)

for autotext in autotexts:
    autotext.set_fontsize(14)
    autotext.set_fontweight('bold')

ax.set_title('Proporção de Permanência', fontsize=18, loc='left', pad=20)

# Remove o círculo central para visual mais limpo
ax.axis('equal')

fig.patch.set_facecolor('white')
fig.patch.set_edgecolor('lightgray')

fig.savefig('grafico_evasao.jpeg', dpi=300, bbox_inches='tight')

plt.show()

"""evasão baseada em genero

"""

import seaborn as sns


# Copiar e preparar dados
dados_plot = dados_normalizados.copy()
dados_plot['genero'] = dados_plot['genero'].replace({'Male': 'Homens', 'Female': 'Mulheres'})

# Cálculos
proporcao = dados_plot.groupby('genero')['desistência'].mean().reset_index()
proporcao.columns = ['genero', 'proporcao']

total = dados_plot['genero'].value_counts().reset_index()
total.columns = ['genero', 'total']

grafico_df = proporcao.merge(total, on='genero')

grafico_fp = grafico_df.sort_values(by='proporcao', ascending=False).reset_index(drop=True)

# Estilo moderno
sns.set(style="whitegrid")

# Plot
fig, ax = plt.subplots(figsize=(10, 5))

# Barras de proporção (horizontal)
cores = {'Homens': '#4A90E2', 'Mulheres': '#FF69B4'}
barras = sns.barplot(
    data=grafico_df,
    y='genero',
    x='proporcao',
    palette=cores,
    ax=ax
)

# Adicionar valores de proporção nas barras
for i, row in grafico_df.iterrows():
    ax.text(
        row['proporcao'] + 0.01, i,
        f"{row['proporcao']:.1%}",
        color='black',
        va='center',
        fontsize=11
    )

# Adicionar total de clientes à direita
for i, row in grafico_df.iterrows():
    ax.text(
        1.02, i,
        f"Total: {row['total']}",
        color='gray',
        va='center',
        fontsize=10
    )

# Limpar layout
ax.set_xlim(0, 1.1)
ax.set_xlabel('Proporção de Evasão', fontsize=12)
ax.set_ylabel('')
ax.set_title('Proporção de Evasão por Gênero', fontsize=15, loc='center')
sns.despine(left=True, bottom=True)

plt.tight_layout()

fig.savefig('grafico_genero.jpeg', dpi=300, bbox_inches='tight')
plt.show()

"""evasão baseada no método de pagamento"""

dados_plot = dados_normalizados.copy()
dados_plot['forma_pagamento'] = dados_plot['forma_pagamento'].replace({'Bank transfer (automatic)': 'Transferência  Bancária automática', 'Credit card (automatic)': 'Cartão de Crédito','Electronic check':'Débito automático','Mailed check':'Pagamento físico'})

proporcao_fp = dados_plot.groupby('forma_pagamento')['desistência'].mean().reset_index()
proporcao_fp.columns = ['forma_pagamento', 'proporcao']

total_fp = dados_plot['forma_pagamento'].value_counts().reset_index()
total_fp.columns = ['forma_pagamento', 'total']

grafico_fp = proporcao_fp.merge(total_fp, on='forma_pagamento')
grafico_fp = grafico_fp.sort_values(by='proporcao', ascending=False).reset_index(drop=True)

plt.figure(figsize=(10, 6))
ax = sns.barplot(
    data=grafico_fp,
    x='forma_pagamento',
    y='proporcao',
    palette='Set2'
)

for i in range(len(grafico_fp)):
    ax.text(
        i,
        grafico_fp['proporcao'][i] + 0.01,
        f"Total: {grafico_fp['total'][i]}",
        ha='center',
        va='bottom',
        fontsize=10,
        color='black'
    )

# Ajustes
ax.set_title('Proporção de Desistência por Forma de Pagamento', fontsize=16)
ax.set_ylabel('Proporção de Desistência')
ax.set_xlabel('Forma de Pagamento')
plt.xticks(rotation=0)
ax.set_ylim(0, grafico_fp['proporcao'].max() + 0.05)
sns.despine()
plt.tight_layout()

fig.savefig('grafico_pagamento.jpeg', dpi=300, bbox_inches='tight')
plt.show()

"""evasão por tipo de contrato"""

dados_normalizados.tipo_contrato.unique()

dados_plot = dados_normalizados.copy()
dados_plot['tipo_contrato'] = dados_plot['tipo_contrato'].replace({'One year': '1 ano', 'Month-to-month': 'Mensal','Two year':'2 anos'})

proporcao_fp = dados_plot.groupby('tipo_contrato')['desistência'].mean().reset_index()
proporcao_fp.columns = ['tipo_contrato', 'proporcao']

total_fp = dados_plot['tipo_contrato'].value_counts().reset_index()
total_fp.columns = ['tipo_contrato', 'total']

grafico_fp = proporcao_fp.merge(total_fp, on='tipo_contrato')
grafico_fp = grafico_fp.sort_values(by='proporcao', ascending=False).reset_index(drop=True)

plt.figure(figsize=(10, 6))
ax = sns.barplot(
    data=grafico_fp,
    x='tipo_contrato',
    y='proporcao',
    palette='Set2'
)

for i in range(len(grafico_fp)):
    ax.text(
        i,
        grafico_fp['proporcao'][i] + 0.01,
        f"Total: {grafico_fp['total'][i]}",
        ha='center',
        va='bottom',
        fontsize=10,
        color='black'
    )

# Ajustes
ax.set_title('Proporção de Desistência por Tipo de Contrato', fontsize=16)
ax.set_ylabel('Proporção de Desistência')
ax.set_xlabel('Tipo de Contrato')
plt.xticks(rotation=0)
ax.set_ylim(0, grafico_fp['proporcao'].max() + 0.05)
sns.despine()
plt.tight_layout()

fig.savefig('grafico_contrato.jpeg', dpi=300, bbox_inches='tight')
plt.show()

"""Cálculo da correlação com a evasão de clientes



"""

# Selecionando somente colunas numéricas
dados_numericos = dados_normalizados.select_dtypes(include=['int64', 'float64'])

# Calcula a matriz de correlação
matriz_corr = dados_numericos.corr()

# Ordena os fatores mais correlacionados com a evasão
correlacoes_com_desistencia = matriz_corr['desistência'].sort_values(ascending=False)
print(correlacoes_com_desistencia)

"""# Relatório

Este projeto visa analisar e procurar os motivos da evasão de clientes.



 A primeira etapa do projeto foi a de Extração, esse o fundamental para o ínicio de todo projeto.

Primeiro passo: transformar o arquivo JSON em um dataframe;

Segundo passo:  Normalizar as colunas que estavam aninhadas.

---



Tranformação:

Esse responsável pela Limpeza e padronização de dados.
Primeiro passo: Verificar o tipo de dados de cada coluna;

Segundo passo: Criação de um Dicionário de dados de cada coluna.Com o seu nome atual seguido de sua função


Terceiro passo: Verificar se há ausencia de valores ou duplicidade de dados e se é preciso mudar a tipagem de alguma coluna

Quarto passo: Tradução das colunas para o Português;


Quinto Passo: Conversão de algumas colunas para se tornarem valores binários


Sexto passo: Vimos a correlação entre a evasão e os tipos de dados
---




Análise Exploratória de Dados:

 na qual analisamos feitas, incluindo gráficos e visualizações para identificar padrões.

Primeiro passo: Criação de um gráfico de pizza acerca da porcentagem de evasão de clientes

Segundo passo: Criação de um gráfico de barras horizontais acerca da evasão baseada em gênero

Terceiro passo: Criação de um gráfico de barras verticais acerca da evasão baseada no método de pagamento

Quarto passo:  Criação de um gráfico de barras verticais acerca da evasão por tipo de contrato

---
Conclusões e Insights:

Podemos ver que as principais motivações para a evasão de clientes esta atreladado a forma de pagamento "débito auttomático" e assinaturas mensais ,ou seja, aquelas que deixam o usuário atrelado a empresa por um prazo mês a mês

---

Recomendações:

No meu entedimento e com base nos dados e gráficos obtidos a principal forma de cativar e garantir a pemanência de clientes é garantir vantagens em planos anuais, pois é neles que você ganha o compromisso com a empresa e barateia custos para o próprio, e foenecer possivelmente um perìodo de teste para o cliente ver a qualidade do produto.
"""